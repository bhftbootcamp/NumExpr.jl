var documenterSearchIndex = {"docs":
[{"location":"#NumExpr.jl","page":"Home","title":"NumExpr.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The NumExpr library is designed to handle and evaluate arithmetic expressions. It enables parsing and analyzing expressions, as well as performing calculations with user-defined functions.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you haven't installed our local registry yet, do that first:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] registry add https://github.com/bhftbootcamp/Green.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, to install NumExpr, simply use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add NumExpr","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is an example usage of NumExpr:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using NumExpr\nusing NumExpr: Func, Variable\n\nconst local_vars = Dict{String,Float64}(\n    \"my_var\"           => 1,\n    \"my_var{tag1='x'}\" => 2,\n)\n\nconst global_vars = Dict{String,Float64}(\n    \"my_var\"           => 3,\n    \"my_var[tag1='x']\" => 4,\n)\n\nfunction NumExpr.eval_expr(var::Variable)\n    return get(isglobal_scope(var) ? global_vars : local_vars, var[], NaN)\nend\n\nfunction NumExpr.call(::Func{:maximum}, x::Number...)\n    return maximum(x)\nend\n\nfunction NumExpr.call(::Func{:sin}, x::Number)\n    return sin(x)\nend\n\nexpr = parse_expr(\"sin(maximum({my_var}, [my_var], my_var{tag1='x'}, my_var[tag1='x'])) + 10\");\n\njulia> eval_expr(expr)\n9.243197504692072","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package lets you set up an expression and then calculate it using data from anywhere, like databases or APIs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Serde\nusing EasyCurl\n\nusing NumExpr\nusing NumExpr: Func, Variable, NumVal, StrVal, ExprNode, GlobalScope, LocalScope\n\nstruct VarCtx\n    base_url::String\nend\n\nstruct avgPrice\n    price::Float64\nend\n\nfunction my_eval(ctx::VarCtx, var::Variable{GlobalScope})\n    http_request = curl_get(ctx.base_url, query = \"symbol=\" * var[])\n    return deser_json(avgPrice, curl_body(http_request)).price\nend\n\nmy_eval(::VarCtx, x::NumVal) = x[]\nmy_eval(::VarCtx, x::StrVal) = x[]\n\nfunction my_eval(ctx::VarCtx, node::ExprNode)\n    args = map(x -> my_eval(ctx, x), node.args)\n    return call(ctx, node.head, args...)\nend\n\ncall(::VarCtx, x...) = NumExpr.call(x...)\n\nconst local_parameters = Dict{String,Float64}(\n    \"rtol\" => 1e-3, \n    \"atol\" => 1e-2\n)\n\nfunction my_eval(::VarCtx, var::Variable{LocalScope})\n    return get(local_parameters, var[], NaN)\nend\n\nfunction NumExpr.call(::Func{:isapprox}, x::Number, y::Number, atol::Number, rtol::Number)\n    return isapprox(x, y; atol, rtol)\nend\n\nvars_context = VarCtx(\"https://api.binance.com/api/v3/avgPrice\")\n\nnode = parse_expr(\"isapprox([ADABTC] * [BTCUSDT], [ADAUSDT], atol, rtol)\")\n\njulia> my_eval(vars_context, node)\ntrue","category":"page"},{"location":"pages/expr_syntax/#syntax","page":"Expression Syntax","title":"Expression Syntax","text":"","category":"section"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"This section outlines the basic syntax rules that expressions must adhere to.","category":"page"},{"location":"pages/expr_syntax/#numeric_vals","page":"Expression Syntax","title":"Numeric values","text":"","category":"section"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Integer values, floating-point values, and exponential notation values can be used in expressions.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"42\")\n42.0\n\njulia> typeof(expr)\nNumVal{Float64}\n\njulia> eval_expr(expr)\n42.0","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"During parsing, numeric values correspond to the Number type.","category":"page"},{"location":"pages/expr_syntax/#Operations-on-Numbers","page":"Expression Syntax","title":"Operations on Numbers","text":"","category":"section"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"The following operations are defined for numeric values:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Arithmetic:\n+: addition\n-: subtraction\n*: multiplication\n/: division\n^: exponentiation","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"1 + 2 * 3\")\nExprNode(\n  +,\n  Union{AbstractExpr, ExprNode}[\n    1.0,\n    ExprNode(\n      *,\n      Union{AbstractExpr, ExprNode}[\n        2.0,\n        3.0\n      ],\n    ),\n  ],\n)\n\njulia> typeof(expr)\nExprNode\n\njulia> eval_expr(expr)\n7.0","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Logical:\n>: greater than\n<: less than\n>=: greater than or equal to\n<=: less than or equal to\n!=: not equal to\n==: equal to","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"1 < 3\")\nExprNode(\n  <,\n  Union{AbstractExpr, ExprNode}[\n    1.0,\n    3.0\n  ],\n)\n\njulia> typeof(expr)\nExprNode\n\njulia> eval_expr(expr)\ntrue","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Mathematical:\nabs: absolute value\nsqrt: square root\nsin: sine\ncos: cosine\natan: arctangent\nexp: exponent\nlog: logarithm","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"abs(-1) + cos(0)\")\nExprNode(+\n  Union{AbstractExpr, ExprNode}[\n    ExprNode(\n      abs,\n      Union{AbstractExpr, ExprNode}[\n        ExprNode(\n          -,\n          Union{AbstractExpr, ExprNode}[\n            1.0\n          ],\n        ),\n      ],\n    ), \n    ExprNode(\n      cos,\n      Union{AbstractExpr, ExprNode}[\n        0.0\n      ],\n    ),\n  ],\n)\n\njulia> typeof(expr)\nExprNode\n\njulia> eval_expr(expr)\n2.0","category":"page"},{"location":"pages/expr_syntax/#string_vals","page":"Expression Syntax","title":"String values","text":"","category":"section"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Expressions can also contain string values by enclosing them with single quotes (') on both sides.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\" 'its my string' \")\nits my string\n\njulia> typeof(expr)\nStrVal\n\njulia> eval_expr(expr)\n\"its my string\"","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Inside such a string, no other single quote characters can be present. During parsing, string values correspond to the String type.","category":"page"},{"location":"pages/expr_syntax/#Operations-on-Strings","page":"Expression Syntax","title":"Operations on Strings","text":"","category":"section"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"The following operations are defined for string values:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"*: concatenation\n^: repetition\nLogical:\n>: greater than\n<: less than\n>=: greater than or equal to\n<=: less than or equal to\n!=: not equal to\n==: equal to","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"'Julia' * 'Lang' * '❤️'\")\nExprNode(\n  *,\n  Union{AbstractExpr, ExprNode}[\n    Julia,\n    Lang,\n    ❤️,\n  ],\n)\n\njulia> eval_expr(expr)\n\"JuliaLang❤️\"","category":"page"},{"location":"pages/expr_syntax/#variable_vals","page":"Expression Syntax","title":"Variables","text":"","category":"section"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Finally, the most important type of values are variable values. Referring to them within an expression can consist of two parts:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"(required) the regular variable name according to the variable naming rules.\n(optional) tags related to this variable.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Let's take a closer look at the syntax for the tag system:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Tags are specified inside curly braces {} or square brackets [] immediately following the variable name.\nTags can be specified in any order and are listed with commas without spaces.\nTags consist of a key-value pairs in the form of key='value'.\nThe name should contain only letters and numbers without spaces, and the first character of the name should be a letter.\nThe tag value must be a string value.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"note: Note\nTags can be used as an extended variable name.","category":"page"},{"location":"pages/expr_syntax/#Variable-scopes","page":"Expression Syntax","title":"Variable scopes","text":"","category":"section"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"For convenience, variables can be classified into local and global ones. The user can define which variables belong to which of such formats.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"For the following examples, we will declare two dictionaries that will be responsible for global and local variables:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"const local_vars = Dict{String,Float64}(\n    \"var\"              => 1,\n    \"var{tag='value'}\" => 2,\n)\n\nconst global_vars = Dict{String,Float64}(\n    \"var\"              => 3,\n    \"var[tag='value']\" => 4,\n)","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"As well as a function that will extract the values of variables in the process of calculating expressions","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"function NumExpr.eval_expr(var::NumExpr.Variable)\n    return get(isglobal_scope(var) ? global_vars : local_vars, var[], NaN)\nend","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"note: Note\nCurrently, this is done only to facilitate the separation of variables into two formats and is not related to scope. This division is intended for implementing additional functionality.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"During parsing, local variables correspond to the type Variable{LocalScope}, and global ones to Variable{GlobalScope}.","category":"page"},{"location":"pages/expr_syntax/#Local-variables","page":"Expression Syntax","title":"Local variables","text":"","category":"section"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Local variables specified when using {} brackets for tags or in the absence of a tag.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"By default:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"var\")\nvar\n\njulia> typeof(expr)\nVariable{LocalScope}\n\njulia> var = eval_expr(expr)\n1.0\n\njulia> typeof(var)\nFloat64","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"By local tag:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"var{tag='value'}\")\nvar{tag='value'}\n\njulia> typeof(expr)\nVariable{LocalScope}\n\njulia> var = eval_expr(expr)\n2.0","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Calling a local variable without tags:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"{var}\")\nvar\n\njulia> eval_expr(expr)\n1.0","category":"page"},{"location":"pages/expr_syntax/#Global-variables","page":"Expression Syntax","title":"Global variables","text":"","category":"section"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Global variables specified when using [] brackets for tags.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Calling a global variable without tags:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"[var]\")\nvar\n\njulia> typeof(expr)\nVariable{GlobalScope}\n\njulia> eval_expr(expr)\n3.0","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"By global tag:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"var[tag='value']\")\nvar[tag='value']\n\njulia> typeof(expr)\nVariable{GlobalScope}\n\njulia> eval_expr(expr)\n4.0","category":"page"},{"location":"pages/expr_syntax/#Variable-values","page":"Expression Syntax","title":"Variable values","text":"","category":"section"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"To interpret the variables specified in the expression as concrete values during the calculation process, the following steps need to be taken:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Determine the data source from which variables can be extracted using their full name (including tags, which should be sorted in alphabetical order). For example, a dictionary:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"colors = Dict{String, UInt32}(\n    \"color\"                 => 0xffffff,\n    \"color[name='red']\"     => 0xff0000,\n    \"color[name='green']\"   => 0x00ff00,\n    \"color[name='blue']\"    => 0x0000ff,\n    \"color[name='yellow']\"  => 0xffff00,\n    \"color[name='cyan']\"    => 0x00ffff,\n    \"color[name='magenta']\" => 0xff00ff,\n)","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"note: Note\nThe full name of a Variable type variable can be obtained by applying the unary operator [] to the object.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Then, it is necessary to overload the function that will extract variable values from their source.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"For example, let's request the value for the variable name var from the colors dictionary:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"NumExpr.eval_expr(var::NumExpr.Variable) = get(colors, var[], NaN)","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Now, during the evaluation of the expression, variables will be interpreted as numbers.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"color\");\n\njulia> eval_expr(expr)\n0x00ffffff\n\njulia> expr = parse_expr(\"color[name='red'] + color[name='green'] + color[name='blue']\");\n\njulia> eval_expr(expr)\n0x0000000000ffffff","category":"page"},{"location":"pages/expr_syntax/#custom_func","page":"Expression Syntax","title":"Custom Functions","text":"","category":"section"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"In addition to predefined functions, users can define their own. To define a new operation on the elements mentioned earlier, you need to define a new method for the NumExpr.call function.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"The first argument of such a method should be of type ::NumExpr.Func{:S}, where S is the name of the new function.\nSubsequent arguments should correspond to the required arguments of the defined function.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"For example, for a function max(x::Number, y::Number), you need to define the following method:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"function NumExpr.call(::NumExpr.Func{:max}, x::Number, y::Number)\n    return max(x, y)\nend","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Now, expressions containing such a function can be correctly processed.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"max(5, 10) + max(20, 3)\");\n\njulia> eval_expr(expr)\n30.0","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"For functions with an unknown number of arguments the method can look like this:","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"function NumExpr.call(::NumExpr.Func{:sum}, x::Number...)\n    return sum(x)\nend","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"Now we can call the sum function with any number of arguments.","category":"page"},{"location":"pages/expr_syntax/","page":"Expression Syntax","title":"Expression Syntax","text":"julia> expr = parse_expr(\"sum(6, 4) + sum(5, 15, 10)\");\n\njulia> eval_expr(expr)\n40.0","category":"page"},{"location":"pages/api_reference/#api","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"pages/api_reference/","page":"API reference","title":"API reference","text":"NumExpr.ExprNode\nNumExpr.Variable\nNumExpr.parse_expr\nNumExpr.eval_expr(::NumExpr.ExprNode)\nNumExpr.eval_expr(::NumExpr.Variable)","category":"page"},{"location":"pages/api_reference/#NumExpr.ExprNode","page":"API reference","title":"NumExpr.ExprNode","text":"ExprNode\n\nRepresents a transitional nested obejct obtained after parsing by parse_expr function. Used by eval_expr function for evaluations an expression.\n\nFields\n\nhead::AbstractExpr: Leading variable or operation of current expression layer.\nargs::Vector{Union{AbstractExpr,ExprNode}}: Elements of current expression node such as variables or another operations.\n\n\n\n\n\n","category":"type"},{"location":"pages/api_reference/#NumExpr.Variable","page":"API reference","title":"NumExpr.Variable","text":"Variable{S<:AbstractScope}\n\nRepresents custom user defined variable in expression after parsing. Type S must be one of LocalScope or GlobalScope.\n\nnote: Note\nFull name of the variable can be obtain by empty operator of getting index e.g []. It may be usefull in some function overloadings.\n\nFor more information see section Variables.\n\nFields\n\nval::String: Full name of the variable including its tags.\nname::String: The variable name without tags\ntags::Dict{String,String}: Tags of the variable.\n\nExamples\n\njulia> const vars = Dict{String,Float64}(\n           \"var\"              => 1,\n           \"var{tag='value'}\" => 2,\n       );\n\njulia> NumExpr.eval_expr(var::NumExpr.Variable) = get(vars, var[], NaN)\n\njulia> var = parse_expr(\"var{tag='value'}\")\nvar{tag='value'}\n\njulia> typeof(var)\nNumExpr.Variable{NumExpr.LocalScope}\n\njulia> var_name(var)\n\"var\"\n\njulia> var_tags(var)\nDict{String, String} with 1 entry:\n  \"tag\" => \"value\"\n\njulia> var[]\n\"var{tag='value'}\"\n\n\n\n\n\n","category":"type"},{"location":"pages/api_reference/#NumExpr.parse_expr","page":"API reference","title":"NumExpr.parse_expr","text":"parse_expr(str::AbstractString) -> ExprNode\n\nParse the string expression x and turn it into nested ExprNode that can be evaluated by eval_expr.\n\nFor more information see syntax guide.\n\nExamples\n\njulia> colors = Dict{String,UInt32}(\n           \"color[name='red']\"   => 0xff0000,\n           \"color[name='green']\" => 0x00ff00,\n           \"color[name='blue']\"  => 0x0000ff,\n       );\n\njulia> NumExpr.eval_expr(var::NumExpr.Variable) = get(colors, var[], NaN)\n\njulia> expr = parse_expr(\"color[name='red'] + color[name='blue']\")\nNumExpr.ExprNode(\n    +,\n    Union{NumExpr.AbstractExpr, NumExpr.ExprNode}[\n        color[name='red'],\n        color[name='blue'],\n    ],\n)\n\n\n\n\n\n","category":"function"},{"location":"pages/api_reference/#NumExpr.eval_expr-Tuple{NumExpr.ExprNode}","page":"API reference","title":"NumExpr.eval_expr","text":"eval_expr(expr::ExprNode)\n\nEvaluate the expression object expr obtained after parsing by the function parse_expr.\n\nFor more information see syntax guide.\n\nExamples\n\njulia> expr = parse_expr(\"1 + 2^3 + 4\");\n\njulia> eval_expr(expr)\n13.0\n\njulia> expr = parse_expr(\"sin(10)^2 + cos(10)^2\");\n\njulia> eval_expr(expr)\n1.0\n\njulia> expr = parse_expr(\"'a' * 'b'\");\n\njulia> eval_expr(expr)\n\"ab\"\n\n\n\n\n\n","category":"method"},{"location":"pages/api_reference/#NumExpr.eval_expr-Tuple{NumExpr.Variable}","page":"API reference","title":"NumExpr.eval_expr","text":"eval_expr(x::Variable)\n\nThis function defines the behavior when evaluating the values of variables in a parsed expression.\n\nnote: Note\nInitially, this function simply returns the value x, but can be overloaded to define new behavior for retrieving variable data from a new source.\n\nFor more information see variables.\n\nExamples\n\njulia> colors = Dict{String,UInt32}(\n           \"color[name='red']\"   => 0xff0000,\n           \"color[name='green']\" => 0x00ff00,\n           \"color[name='blue']\"  => 0x0000ff,\n       );\n\njulia> NumExpr.eval_expr(var::NumExpr.Variable) = get(colors, var[], NaN)\n\njulia> expr = parse_expr(\"color[name='red'] + color[name='blue']\");\n\njulia> eval_expr(expr)\n0x00ff00ff\n\n\n\n\n\n","category":"method"}]
}
